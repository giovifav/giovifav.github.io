[
  {
    "title": "Home",
    "url": "index.html",
    "date": "2025-01-01",
    "content": "If you are looking for the English version, please click the button at the top. Ciao, sono Giovanni Favaro. Benvenuto nel mio laboratorio digitale. Qui raccolgo e condivido le mie creazioni software. Sono un programmatore autodidatta, spinto dalla curiosità e dalla passione per la creazione, che mi ha portato a esplorare progetti molto diversi: dagli strumenti per sviluppatori ai giochi in stile retro. Ho appena rilasciato il mio ultimo progetto, Whisperli , un'applicazione web per creare la tua atmosfera sonora ideale. Combina diversi suoni ambientali per rilassarti, concentrarti o addormentarti, direttamente dal tuo browser. × ‹ ›"
  },
  {
    "title": "Gio's static site generator",
    "url": "gssg/index.html",
    "date": "2025-09-17",
    "content": "Gio's Static Site Generator Un generatore di siti statici moderno e intuitivo, sviluppato in Python . Si distingue per la sua interfaccia testuale (TUI) basata su Textual, che rende la gestione del sito semplice e diretta, senza bisogno di comandi complessi. Caratteristiche Elaborazione Markdown: Converte i file Markdown in pagine HTML, utilizzando i metadati definiti nel frontmatter. Temi personalizzabili: Offre template flessibili con Jinja2 per personalizzare l'aspetto del sito. Gallerie automatiche: Genera gallerie fotografiche complete di miniature e un visualizzatore integrato. Gestione blog: Permette di organizzare i contenuti in articoli, ordinandoli cronologicamente. Navigazione automatica: Crea automaticamente sidebar e breadcrumbs per una navigazione intuitiva. Multilingua: Supporta l'italiano e l'inglese. Scarica il progetto da GitHub Questo progetto è open source e rilasciato sotto licenza MIT. × ‹ ›"
  },
  {
    "title": "Piece by piece puzzle",
    "url": "jigsaw/index.html",
    "date": "2025-09-17",
    "content": "Jigsaw Puzzle Un rilassante gioco di puzzle per ricomporre immagini in quadri completi. Panoramica del gioco Il gioco presenta puzzle basati su fotografie , divise in categorie come animali, paesaggi, architettura e persone. Puoi scegliere tra diversi livelli di difficoltà, da un semplice 3x3 a un più impegnativo 8x8 . Download del gioco Come si gioca Seleziona un'immagine dal menu. Scegli il livello di difficoltà. Usa il mouse o il touch per spostare i pezzi e lo zoom per i dettagli. Una volta completato, vedrai il tuo tempo e il numero di mosse. Puoi riprendere una partita salvata o affrontare la modalità hardcore , senza suggerimenti. Caratteristiche Immagini categorizzate: Animali, paesaggi, architettura, persone. Livelli di difficoltà: Da 3x3 a 8x8. Modalità hardcore: Sfida senza suggerimenti. Salva/Riprendi partita: Non perdi mai i tuoi progressi. Classifica: Confronta il tuo tempo con quello degli altri giocatori. Opzioni audio: Controlli separati per musica ed effetti sonori. Supporto multilingua: Disponibile in italiano e inglese. Immagini personalizzate: Usa le tue foto per creare nuovi puzzle. Controlli ottimizzati: Adatto sia per mouse che per dispositivi touch. × ‹ ›"
  },
  {
    "title": "LuaPyDoc",
    "url": "luapydoc/index.html",
    "date": "2025-01-01",
    "content": "Luapydoc Luapydoc è un generatore di documentazione basato su Python per codebase Lua. Analizza commenti di documentazione in stile LDoc nei file sorgente Lua e genera un sito web di documentazione HTML completo, navigabile, con evidenziazione della sintassi, funzionalità di ricerca e molto altro. Repository Esempio output Caratteristiche Analizza commenti di documentazione LDoc (@param, @return, @usage, ecc.) Supporta funzioni, variabili, tabelle e tipi Genera pagine HTML responsive con tema scuro Evidenziazione della sintassi per codice Lua usando Pygments Navigazione a barra laterale basata su albero per moduli, classi e funzioni Ricerca a testo completo con indice Design responsive per mobile e desktop"
  },
  {
    "title": "Navigate and loot",
    "url": "Nal/index.html",
    "date": "2025-09-17",
    "content": "Navigate and Loot Un piccolo gioco a tema piratesco dove devi navigare, saccheggiare e sopravvivere. Creato per la GDevelop 3D Jam, si è classificato all'11° posto su oltre 100 partecipanti. Come si gioca Navigazione: Usa i tasti WASD per muoverti. Combattimento: Lancia palle di cannone con i tasti freccia . Risorse: Premi spazio per pescare e aumentare il morale dell'equipaggio. Un morale alto ti rende più veloce. Bottino: Premi spazio per raccogliere i tesori che trovi vicino alla tua nave. Note Problemi noti: La versione Jam presenta un bug che impedisce la morte del giocatore e potrebbe avere problemi di risoluzione su alcuni dispositivi mobili. Dal creatore: \"Essendo il mio primo gioco realizzato con GDevelop, sono molto soddisfatto del risultato.\" Prova il gioco × ‹ ›"
  },
  {
    "title": "Play64 Docs",
    "url": "play64/documentation.html",
    "date": "2025-09-17",
    "content": "Play64 is a fantasy console developed for The Tool Jam 2025. It features a D-pad and two action buttons, with a display capable of rendering four shades of violet. Games are written in Lua 5.1. The console itself is implemented using BlitzMax NG and the Raylib graphics library. https://github.com/user-attachments/assets/d3407e81-d0d5-4821-9e4d-ee68e37a5cda Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game How to release your game To prepare your game for release, edit the config.ini file: set Game to your game's internal name, Title to the window title, and Intro to False . Remove any unused files from the carts directory. You may then rename the play64.exe executable as desired. \"config.ini\" file [Settings] ; This is the configuration file for the Play64 fantasy console ; It contains settings for the console Fullscreen=False ; Set to True for fullscreen mode ; Set to False for windowed mode Width=800 ; Width of the window in pixels Height=600 ; Height of the window in pixels Intro=True ; Set to True to show the intro screen ; Set to False to skip the intro screen Game= ; The name of the game to load ; Leave empty to load the selection screen Title=Play64 fantasy console ; This is the title of the window ; It will be displayed in the title bar ; The title of the window can be changed in the code input The object module offer an interface to the input system input.down() Return a string with the key that is pressed print(input.down()) -- print up or down or left or right or a or b input.pressed() Return a string with the key that has been pressed print(input.pressed()) -- print up or down or left or right or a or b input.released() Return a string with the key that has been released print(input.released()) -- print up or down or left or right or a or b draw The object module offer an interface to the drawing commands colors palette 4 color palette 0 = darkest, 3 = brightest draw.background(color:Int) Change the color of background 0 = darkest, 3 = brightest draw.background(0) draw.color(color:Int) set the color of the draw command 0 = darkest, 3 = brightest draw.color(3) draw.point(x:Int, y:Int) Draw a pixel --draw a point draw.point(32,18) draw.line(startx:Int, startY:Int, endX:Int, endY:Int) Draw a line --draw a line draw.line(0,0,18,36) draw.rect(x:Int, y:Int, Width:Int, height:Int) Draw a rectangle --draw a rectangle draw.rect(0,0,20,20) draw.text(text:String, x:Int, y:Int, size:Int) Print a string of text Minimum size = 10 draw.text(&quot;a string of text&quot;,0,0,15) draw.circle(x:Int, y:Int, Radius:Int) Draw a circle --draw a circle draw.rect(30,30,10) draw.triangle(x1:Int, y1:Int, x2:Int, y2:Int, x3:Int, y3:Int) Draw a triangle --draw a triangle draw.triangle(1,1,63,1,32,63) draw.sprite(title:String, x:Int, y:Int) draw.sprite(&quot;enemy&quot;, 10,10) -- same as sprites.draw(&quot;enemy&quot;,10,10) app The object module offer an interface for manage all the app settings app.dt() Return the delta time in seconds The default game target fps is 30 frame per second. app.title(title:String) set the title of the window app.width(width:Int) set the width of the window app.height(heigth:Int) set the height of the window app.fullscreen() toggle the fullscreen mode app.reset() reset the cart and go back to selection screen app.restart() restart the current cart app.loadCart(cart:String) load a specific cart app.loadCart(&quot;snake&quot;) app.save(key:String, value:String) save a value of the current game app.save(&quot;highscore&quot;, &quot;1000&quot;) app.load(key:String, value:String) load a value of the current game app.load(&quot;highscore&quot;) Sound The object module offer an interface to sound system sound.play(sound:String) play a built-in sound by name --play bump sound effect sound.play(&quot;bump&quot;) Possible values: bottle_break, bump, cancel, cat_meow, click, confirm, crunch, digital_alarm, dog_bark, door_slow_open, drink, evil_laugh, explosion, gun, hurt, jump, laser_gun, low_health, menu_in, menu_out, monster_scream, notso_confirm, pause, phone_ring, powerdown, powerup, siren, steps, sword_slash, thunder, trampoline, water_splash, Camera The object module offer an interface to the camera system camera.target(x:Int, y:Int) --set position of the camera at 10, 10 camera.target(10,10) camera.offset(x:Int, y:Int) --set offset of the camera at 10, 10 camera.offset(10,10) camera.rotation(deg:Float) --set rotation of the camera at 45 camera.target(45.0) camera.zoom(zoom:Float) --set zoom of the camera at 1.2 camera.target(1.2) camera.reset() --reset the camera camera.reset() Sprites sprites.add(title:String, data:String) Return title:String local enemySprite = [[ 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 1 1 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 1 0 ]] sprite = sprites.add(&quot;enemy&quot;, enemySprite) -- sprite == &quot;enemy&quot; sprites.draw(title:String, x:Int, y:Int) sprites.draw(&quot;enemy&quot;,10,10) -- same as draw.sprite(&quot;enemy&quot;, 10,10) sprites.collision(sprite1:String, x1:Int, y1:Int, sprite2:String, x2:Int, y2:Int) Return 1 in case of collision if sprites.collision(&quot;player&quot;,player.x,player.y,&quot;enemy&quot;,enemy.x,enemy.Y) == 1 then --Collision! Do something end Timer The object module offer an interface for manage timers timer.delay(fn, delay) Calls the function fn after the given delay time has passed. Returns the associated event. -- Prints &quot;Hello world!&quot; after 2 seconds timer.delay(function() print(&quot;Hello world!&quot;) end, 2) timer.recur(fn, delay) Calls the function fn at an interval of delay . Returns the associated event. -- Prints timer!&quot; every half-second timer.recur(function() print( timer!&quot;) end, .5) Chaining events To avoid having to deeply nest several functions when creating chains of events, the :after() method can be called on an event returned by timer.delay() . You can keep using the :after() method to create complex timed sequences. -- Prints &quot;cat&quot;, &quot;dog&quot;, then &quot;owl&quot;, waiting 1 second between each print timer.delay(function() print(&quot;cat&quot;) end, 1) :after(function() print(&quot;dog&quot;) end, 1) :after(function() print(&quot;owl&quot;) end, 1) Stopping events An event can be stopped and removed at any point by calling its :stop() method. To do this the event must be assigned to a variable when it is created. -- Create a new event local t = timer.delay(function() print( timer!&quot;) end, 10) -- Remove the event before it has a chance to run t:stop() Groups timer provides the ability to create event groups; these are objects which can have events added to them, and which are in charge of updating and handling their contained events. A group is created by calling the timer.group()` function. local group = timer.group() Once a group is created it acts independently of the timer` object, and must be updated each frame using its own update method. group:update() To add a events to a group, the group's :delay() or :recur() methods should be used. group:delay(function() print(&quot;hello world&quot;) end, 4) A good example of where groups are useful is for games where you may have a set of events which effect objects in the game world and which you want to pause when the game is paused. A group's events can be paused by simply neglecting to call its update() method; when a group is destroyed its events are also destroyed. object The object module offer an interface for OOP programming Creating a new class Point = object:extend() function Point:new(x, y) self.x = x or 0 self.y = y or 0 end Creating a new object local p = Point(10, 20) Extending an existing class Rect = Point:extend() function Rect:new(x, y, width, height) Rect.super.new(self, x, y) self.width = width or 0 self.height = height or 0 end Checking an object's type local p = Point(10, 20) print(p:is(Object)) -- true print(p:is(Point)) -- true print(p:is(Rect)) -- false Using mixins PairPrinter = object:extend() function PairPrinter:printPairs() for k, v in pairs(self) do print(k, v) end end Point = object:extend() Point:implement(PairPrinter) function Point:new(x, y) self.x = x or 0 self.y = y or 0 end local p = Point() p:printPairs() Using static variables Point = object:extend() Point.scale = 2 function Point:new(x, y) self.x = x or 0 self.y = y or 0 end function Point:getScaled() return self.x * Point.scale, self.y * Point.scale end Creating a metamethod function Point:__tostring() return self.x .. &quot;, &quot; .. self.y end Tween The object module offer an interface for tweening Tween creation local t = tween.new(duration, subject, target, [easing]) Creates a new tween. duration means how much the change will take until it's finished. It must be a positive number. subject must be a table with at least one key-value. Its values will be gradually changed by the tween until they look like target . All the values must be numbers, or tables with numbers. target must be a table with at least the same keys as subject . Other keys will be ignored. easing can be either a function or a function name (see the easing section below). It's default value is 'linear' t is the object that must be used to perform the changes - see the \"Tween methods\" section below. This function only creates and returns the tween. It must be captured in a variable and updated via t:update(dt) in order for the changes to take place. Tween methods local complete = t:update() Gradually changes the contents of subject to that it looks more like target as time passes. t is a tween returned by tween.new complete is true if the tween has reached its limit (its internal clock is &gt;= duration ). It is false otherwise. When the tween is complete, the values in subject will be equal to target 's. The way they change over time will depend on the chosen easing function. local complete = t:set(clock) Moves a tween's internal clock to a particular moment. t is a tween returned by tween.new clock is a positive number or 0. It's the new value of the tween's internal clock. complete works like in t:update ; it's true if the tween has reached its end, and false otherwise. If clock is greater than t.duration , then the values in t.subject will be equal to t.target , and t.clock will be equal to t.duration . t:reset() Resets the internal clock of the tween back to 0, resetting subject . t is a tween returned by tween.new This method is equivalent to t:set(0) . Easing functions Easing functions are functions that express how slow/fast the interpolation happens in tween. The easing functions can be found in the table tween.easing . They can be divided into several families: linear is the default interpolation. It's the simplest easing function. quad , cubic , quart , quint , expo , sine and circle are all \"smooth\" curves that will make transitions look natural. The back family starts by moving the interpolation slightly \"backwards\" before moving it forward. The bounce family simulates the motion of an object bouncing. The elastic family simulates inertia in the easing, like an elastic gum. Each family (except linear ) has 4 variants: in starts slow, and accelerates at the end out starts fast, and decelerates at the end inOut starts and ends slow, but it's fast in the middle outIn starts and ends fast, but it's slow in the middle family in out inOut outIn Linear linear linear linear linear Quad inQuad outQuad inOutQuad outInQuad Cubic inCubic outCubic inOutCubic outInCubic Quart inQuart outQuart inOutQuart outInQuart Quint inQuint outQuint inOutQuint outInQuint Expo inExpo outExpo inOutExpo outInExpo Sine inSine outSine inOutSine outInSine Circ inCirc outCirc inOutCirc outInCirc Back inBack outBack inOutBack outInBack Bounce inBounce outBounce inOutBounce outInBounce Elastic inElastic outElastic inOutElastic outInElastic When you specify an easing function, you can either give the function name as a string. The following two are equivalent: local t1 = tween.new(10, subject, {x=10}, tween.easing.linear) local t2 = tween.new(10, subject, {x=10}, 'linear') But since 'linear' is the default, you can also do this: local t3 = tween.new(10, subject, {x=10}) Custom easing functions You are not limited to tween's easing functions; if you pass a function parameter in the easing, it will be used. The passed function will need to take 4 parameters: t (time): starts in 0 and usually moves towards duration b (begin): initial value of the of the property being eased. c (change): ending value of the property - starting value of the property d (duration): total duration of the tween And must return the new value after the interpolation occurs. local cubicbezier = function (x1, y1, x2, y2) local curve = love.math.newBezierCurve(0, 0, x1, y1, x2, y2, 1, 1) return function (t, b, c, d) return c * curve:evaluate(t/d) + b end end local label = { x=200, y=0, text = &quot;hello&quot; } local labelTween = tween.new(4, label, {y=300}, cubicbezier(.35, .97, .58, .61)) Credits Engine written in BlitzMax NG Carts written in Lua 5.1 The graphic library is Raylib Classic by rxi for lua OOP Tween by kikito Tick by rxi Sound Effects by Coffee 'Valen' Bat"
  },
  {
    "title": "Play64 fantasy console",
    "url": "play64/index.html",
    "date": "2025-09-17",
    "content": "Play64 Play64 è una console fantasy creata per la \"The Tool Jam 5\". Si tratta di un motore di gioco ideato per sviluppare titoli con un'estetica che ricorda quella della classica Atari 2600. Caratteristiche principali Controlli: Dispone di un D-pad e due pulsanti azione. Grafica: Un display da 64x64 pixel in grado di visualizzare quattro tonalità di viola. Programmazione: I giochi sono scritti in Lua 5.1 . Implementazione: La console è realizzata utilizzando BlitzMax NG e la libreria grafica Raylib . Mappatura dei controlli SU: Tasti FRECCIA SU e W GIÙ: Tasti FRECCIA GIÙ e S SINISTRA: Tasti FRECCIA SINISTRA e A DESTRA: Tasti FRECCIA DESTRA e D Pulsante A: Tasti Z e N Pulsante B: Tasti X e M Comandi aggiuntivi ESC : Chiude l'applicazione. R : Resetta la console. F : Attiva/disattiva la modalità schermo intero. P : Mette in pausa il gioco. Vai al repository GitHub × ‹ › Nome Dimensione Data Scarica docs.pdf 137.8 KB 2025-05-14 13:19 Scarica play64.zip 1.7 MB 2025-05-14 13:22 Scarica"
  },
  {
    "title": "VectorDefense",
    "url": "VectorDefense/index.html",
    "date": "2025-01-01",
    "content": "VectorDefense Un gioco tower defense in sviluppo, creato con il framework LÖVE e scritto in Lua . Descrizione L'obiettivo è difendere la tua base su mappe a griglia, posizionando strategicamente torri per fermare ondate di nemici. Il gioco è costruito con un'architettura modulare, rendendo facile l'aggiunta di nuovi nemici, torri e altri contenuti. Nota Questo progetto è in fase di sviluppo iniziale e non è ancora completamente implementato. × ‹ ›"
  },
  {
    "title": "Voxel64",
    "url": "voxel64/index.html",
    "date": "2025-01-01",
    "content": "Voxel64 Un semplice renderer voxelspace per il framework LÖVE , che simula il volo 3D su terreni usando le mappe di altezza. Questo progetto è basato su voxelspace . Caratteristiche Rendering del terreno procedurale: Crea il terreno dinamicamente usando mappe di altezza e colore. Controlli di volo: Permette di navigare liberamente. Mappe multiple: Include diverse mappe di terreno predefinite. HUD di base: Un'interfaccia a schermo mostra le informazioni principali. Requisiti e avvio Richiede il game engine LÖVE 2D . Per avviare: Esegui il gioco da terminale con il comando: love /path/to/voxel64-master Controlli W/A/S/D: Muovi avanti/sinistra/indietro/destra Frecce SU/GIÙ: Aumenta/diminuisci l'altezza Numeri 1-5: Cambia mappa H : Mostra/nascondi l'HUD Esc : Esci dal gioco Repository GitHub × ‹ ›"
  },
  {
    "title": "Whisperli",
    "url": "whisperli_info/index.html",
    "date": "2025-01-01",
    "content": "Whisperli Un'applicazione web minimalista per creare la tua atmosfera sonora ideale. Combina diversi suoni ambientali per rilassarti, concentrarti o addormentarti, direttamente dal tuo browser. Cosa puoi fare Esplora una vasta libreria di suoni, suddivisa per categorie. Crea la tua miscela nel mixer intuitivo, aggiungendo e rimuovendo elementi. Gestisci il tuo mix: avvia, metti in pausa e salva le tue miscele preferite. Personalizza l'esperienza con vari sfondi e passa facilmente tra temi chiari e scuri. Cerca un suono specifico grazie alla funzione di ricerca integrata. Tecnologie L'applicazione è sviluppata usando: HTML CSS JavaScript (Moduli ES6) Vai al repository GitHub Prova l'applicazione"
  }
]