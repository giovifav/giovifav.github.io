[
  {
    "title": "My Experimental Projects",
    "url": "index.html",
    "date": "2025-01-01",
    "content": "Hello, I'm Giovanni Favaro. Welcome to my portfolio of experimental and developing software projects. This collection features a diverse range of creations from developer tools to games, written in various languages and frameworks. Explore the following projects: Static Site Generator (gssg) - A modern Python-based tool for creating static websites from Markdown Jigsaw Puzzle Game - A relaxing puzzle game built with Love2D featuring real-world images Play64 Fantasy Console - A retro game engine for creating simple Lua-based games Voxel64 Terrain Renderer - A 3D voxel space renderer for Love2D with procedural terrain LuaPyDoc Generator - A Python tool for generating HTML documentation from Lua source code Navigate and Loot Pirate Game - A sailing and plunder game made with GDevelop I Miei Progetti Sperimentali Ciao, sono Giovanni Favaro. Benvenuti nel mio portfolio di progetti software sperimentali e in sviluppo. Questa raccolta presenta una varietà di creazioni dai tool per sviluppatori ai giochi, scritti in vari linguaggi e framework. Esplora i seguenti progetti: Generatore Siti Statici (gssg) - Uno strumento moderno basato su Python per creare siti web statici da Markdown Gioco Puzzle Jigsaw - Un rilassante gioco di puzzle realizzato con Love2D con fotografie reali Play64 - Una fantasy console retro per creare giochi semplici basati su Lua Renderer Voxel64 - Un renderer voxelspace per Love2D Generatore LuaPyDoc - Uno strumento Python per generare documentazione HTML dal codice sorgente Lua Navigate and Loot - Un gioco di navigazione e saccheggio realizzato con GDevelop"
  },
  {
    "title": "Gio's static site generator",
    "url": "gssg/index.html",
    "date": "2025-09-17",
    "content": "Gio's Static Site Generator Un generatore di siti statici moderno e intuitivo scritto in Python con interfaccia terminale basata su Textual. Descrizione Questo strumento permette di creare siti web statici partendo da file Markdown. Offre un'interfaccia grafica semplice per gestire contenuti, applicare temi e generare siti pronti alla pubblicazione. Supporta gallerie di immagini, sistemi blog, navigazione automatica e molto altro. Download Caratteristiche Principali Processamento Markdown : Converte file Markdown in pagine HTML utilizzando frontmatter per metadati. Temi Personalizzabili : Template flessibili con Jinja2 per personalizzare l'aspetto del sito. Gallerie Automatiche : Crea gallerie di immagini con thumbnails e visualizzatore integrato. Sistemi Blog : Organizza contenuti in articoli con ordinamento cronologico. Interfaccia Utente : TUI moderna per gestire siti senza comandi complessi. Navigazione Automatica : Sidebar e breadcrumbs generati automaticamente. Multilingua : Supporto italiano e inglese. Requisiti di Sistema Python 3.8 o superiore Dipendenze elencate in requirements.txt Installazione git clone https://github.com/giovifav/ssg.git cd ssg # Crea ambiente virtuale python -m venv .venv .venv\\Scripts\\activate # Windows # source .venv/bin/activate # macOS/Linux # Installa dipendenze pip install -r requirements.txt # Avvia l'applicazione python main.py Utilizzo Avvia l'applicazione con python main.py . Passi Base Inizializza un nuovo sito : Scegli una cartella e configura nome e autore. Aggiungi contenuto : Crea file .md nella cartella content/ con frontmatter per titolo, data, autore. Aggiungi immagini e assets : Metti file statici nella cartella assets/ . Genera il sito : L'applicazione crea automaticamente l'output HTML nella directory configurata. Struttura di Base di un Sito mio-sito/ ├── content/ │ └── index.md ├── assets/ │ ├── theme.html │ └── theme.css └── config.toml Licenza Questo progetto è open source sotto licenza MIT. Per supporto o segnalazioni, visita il repository GitHub . × ‹ ›"
  },
  {
    "title": "Piece by piece puzzle",
    "url": "jigsaw/index.html",
    "date": "2025-09-17",
    "content": "A relaxing puzzle game where you reassemble images into complete pictures. Game Overview Play with real-world images in categories: animals, landscapes, architecture, and people. Select difficulty levels from easy (3x3 pieces) to hard (8x8 pieces) and assemble the puzzle. Download How to Play Choose an image from the menu. Select difficulty. Move pieces with mouse/touch, use zoom. Complete the puzzle and view your time/moves. Resume saved games or try hardcore mode. Features Categorized images Difficulty levels: 3x3 to 8x8 Hardcore mode (no hints) Save/Resume games Leaderboard Sound &amp; Music controls Italian/English language Custom image support Touch/Mouse friendly Requirements 1024x768 resolution or higher Installation Download game files. Install Love2D from official site. Run game via Love2D. Credits Images: Pexels Music: CC licensed tracks by various artists Framework: Love2D Font: Caviar Dreams Full credits in credits.txt License Images and music: Creative Commons Jigsaw Puzzle Un rilassante gioco di puzzle dove ricomponi immagini in quadri completi. Panoramica del Gioco Gioca con immagini del mondo reale in categorie: animali, paesaggi, architettura e persone. Scegli livelli di difficoltà da facile (3x3 pezzi) a difficile (8x8 pezzi) e assembla il puzzle. Download Come Giocare Scegli un'immagine dal menu. Seleziona difficoltà. Muovi i pezzi con mouse/touch, usa lo zoom. Completa il puzzle e vedi il tuo tempo/mosse. Riprendi partite salvate o prova la modalità hardcore. Caratteristiche Immagini categorizzate Livelli difficoltà: 3x3 a 8x8 Modalità hardcore (senza suggerimenti) Salva/Riprendi partite Classifica Controlli suono &amp; musica Lingua italiano/inglese Supporto immagini personalizzate Adatto touch/mouse Requisiti Risoluzione 1024x768 o superiore Installazione Scarica i file del gioco. Installa Love2D dal sito ufficiale. Avvia il gioco via Love2D. Crediti Immagini: Pexels Musica: Tracce CC di vari artisti Framework: Love2D Font: Caviar Dreams Crediti completi in credits.txt Licenza Immagini e musica: Creative Commons × ‹ ›"
  },
  {
    "title": "LuaPyDoc",
    "url": "luapydoc/index.html",
    "date": "2025-01-01",
    "content": "Luapydoc è un generatore di documentazione basato su Python per codebase Lua. Analizza commenti di documentazione in stile LDoc nei file sorgente Lua e genera un sito web di documentazione HTML completo, navigabile, con evidenziazione della sintassi, funzionalità di ricerca e molto altro. Repository Esempio output Caratteristiche Analizza commenti di documentazione LDoc (@param, @return, @usage, ecc.) Supporta funzioni, variabili, tabelle e tipi Genera pagine HTML responsive con tema scuro Evidenziazione della sintassi per codice Lua usando Pygments Navigazione a barra laterale basata su albero per moduli, classi e funzioni Ricerca a testo completo con indice Design responsive per mobile e desktop Requisiti Python 3.x jinja2 pygments Installazione Clona questo repository. Installa le dipendenze: pip install -r requirements.txt Utilizzo Inserisci i tuoi file sorgente Lua in una directory (es. lua_src ), organizzati in sottodirectory se necessario. Esegui il generatore con le opzioni desiderate (vedi esempi sotto). Apri il file index.html nella directory di output nel tuo browser per visualizzare la documentazione. Opzioni riga di comando # Utilizzo di base con le directory di default python docs_generator.py # Specifica directory sorgente e output personalizzate python docs_generator.py --src-dir ./my_lua_code --output-dir ./my_docs # Utilizzo delle forme brevi python docs_generator.py -s ./src -o ./docs # Specifica solo la directory sorgente (output di default 'docs') python docs_generator.py --src-dir ./lua_src Parametri disponibili: - -s, --src-dir : Directory contenente i file sorgente Lua (default: lua_src ) - -o, --output-dir : Directory dove generare la documentazione (default: docs ) Aiuto completo: python docs_generator.py --help Struttura del progetto docs_generator.py : Script principale che analizza i file Lua e genera documentazione docs_template.html : Template Jinja2 per pagine HTML docs_style.css : Stili CSS per il sito web di documentazione requirements.txt : Dipendenze Python lua_src/ : Directory per file sorgente Lua (creala) docs/ : Directory di output per file HTML generati Come funziona Il generatore lavora in due fasi: 1. Analizza commenti di documentazione (es. --- @param name desc) 2. Li associa a definizioni di funzioni o assegnazioni di variabili 3. Costruisce un albero gerarchico per la navigazione 4. Genera pagine HTML usando template Jinja2 5. Include codice Lua con sintassi evidenziata Personalizzazione Puoi personalizzare l'aspetto modificando docs_style.css e il layout modificando docs_template.html ."
  },
  {
    "title": "Navigate and loot",
    "url": "Nal/index.html",
    "date": "2025-09-17",
    "content": "A little pirate game. Sail, plunder, survive! Made for gdevelop 3d jam. https://minifun.itch.io/navigate-and-lootjam Instructions: Sail with wasd, throw cannonballs with arrow keys, fish with space to boost your crew's morale and go faster. loot the loot near your ship with space. Information: In the jam version a bug does not allow you to die and on some mobile devices there may be problems with resolution. Being my first game with gdevelop I am quite happy with the result. × ‹ ›"
  },
  {
    "title": "Play64 Docs",
    "url": "play64/documentation.html",
    "date": "2025-09-17",
    "content": "Play64 is a fantasy console developed for The Tool Jam 2025. It features a D-pad and two action buttons, with a display capable of rendering four shades of violet. Games are written in Lua 5.1. The console itself is implemented using BlitzMax NG and the Raylib graphics library. https://github.com/user-attachments/assets/d3407e81-d0d5-4821-9e4d-ee68e37a5cda Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game How to release your game To prepare your game for release, edit the config.ini file: set Game to your game's internal name, Title to the window title, and Intro to False . Remove any unused files from the carts directory. You may then rename the play64.exe executable as desired. \"config.ini\" file [Settings] ; This is the configuration file for the Play64 fantasy console ; It contains settings for the console Fullscreen=False ; Set to True for fullscreen mode ; Set to False for windowed mode Width=800 ; Width of the window in pixels Height=600 ; Height of the window in pixels Intro=True ; Set to True to show the intro screen ; Set to False to skip the intro screen Game= ; The name of the game to load ; Leave empty to load the selection screen Title=Play64 fantasy console ; This is the title of the window ; It will be displayed in the title bar ; The title of the window can be changed in the code input The object module offer an interface to the input system input.down() Return a string with the key that is pressed print(input.down()) -- print up or down or left or right or a or b input.pressed() Return a string with the key that has been pressed print(input.pressed()) -- print up or down or left or right or a or b input.released() Return a string with the key that has been released print(input.released()) -- print up or down or left or right or a or b draw The object module offer an interface to the drawing commands colors palette 4 color palette 0 = darkest, 3 = brightest draw.background(color:Int) Change the color of background 0 = darkest, 3 = brightest draw.background(0) draw.color(color:Int) set the color of the draw command 0 = darkest, 3 = brightest draw.color(3) draw.point(x:Int, y:int ) Draw a pixel --draw a point draw.point(32,18) draw.line(startx:Int, startY:Int, endX:Int, endY:Int) Draw a line --draw a line draw.line(0,0,18,36) draw.rect(x:Int, y:Int, Width:Int, height:Int) Draw a rectangle --draw a rectangle draw.rect(0,0,20,20) draw.text(text:String, x:Int, y:Int, size:Int) Print a string of text Minimum size = 10 draw.text(&quot;a string of text&quot;,0,0,15) draw.circle(x:Int, y:Int, Radius:Int) Draw a circle --draw a circle draw.rect(30,30,10) draw.triangle(x1:Int, y1:Int, x2:Int, y2:Int, x3:Int, y3:Int) Draw a triangle --draw a triangle draw.triangle(1,1,63,1,32,63) draw.sprite(title:String, x:Int, y:Int) draw.sprite(&quot;enemy&quot;, 10,10) -- same as sprites.draw(&quot;enemy&quot;,10,10) app The object module offer an interface for manage all the app settings app.dt() Return the delta time in seconds The default game target fps is 30 frame per second. app.title(title:String) set the title of the window app.width(width:Int) set the width of the window app.height(heigth:Int) set the height of the window app.fullscreen() toggle the fullscreen mode app.reset() reset the cart and go back to selection screen app.restart() restart the current cart app.loadCart(cart:String) load a specific cart app.loadCart(&quot;snake&quot;) app.save(key:String, value:String) save a value of the current game app.save(&quot;highscore&quot;, &quot;1000&quot;) app.load(key:String, value:String) load a value of the current game app.load(&quot;highscore&quot;) Sound The object module offer an interface to sound system sound.play(sound:String) play a built-in sound by name --play bump sound effect sound.play(&quot;bump&quot;) Possible values: bottle_break, bump, cancel, cat_meow, click, confirm, crunch, digital_alarm, dog_bark, door_slow_open, drink, evil_laugh, explosion, gun, hurt, jump, laser_gun, low_health, menu_in, menu_out, monster_scream, notso_confirm, pause, phone_ring, powerdown, powerup, siren, steps, sword_slash, thunder, trampoline, water_splash, Camera The object module offer an interface to the camera system camera.target(x:Int, y:Int) --set position of the camera at 10, 10 camera.target(10,10) camera.offset(x:Int, y:Int) --set offset of the camera at 10, 10 camera.offset(10,10) camera.rotation(deg:Float) --set rotation of the camera at 45 camera.target(45.0) camera.zoom(zoom:Float) --set zoom of the camera at 1.2 camera.target(1.2) camera.reset() --reset the camera camera.reset() Sprites sprites.add(title:String, data:String) Return title:String local enemySprite = [[ 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 1 1 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 1 0 ]] sprite = sprites.add(&quot;enemy&quot;, enemySprite) -- sprite == &quot;enemy&quot; sprites.draw(title:String, x:Int, y:Int) sprites.draw(&quot;enemy&quot;,10,10) -- same as draw.sprite(&quot;enemy&quot;, 10,10) sprites.collision(sprite1:String, x1:Int, y1:Int, sprite2:String, x2:Int, y2:Int) Return 1 in case of collision if sprites.collision(&quot;player&quot;,player.x,player.y,&quot;enemy&quot;,enemy.x,enemy.Y) == 1 then --Collision! Do something end Timer The object module offer an interface for manage timers timer.delay(fn, delay) Calls the function fn after the given delay time has passed. Returns the associated event. -- Prints &quot;Hello world!&quot; after 2 seconds timer.delay(function() print(&quot;Hello world!&quot;) end, 2) timer.recur(fn, delay) Calls the function fn at an interval of delay . Returns the associated event. -- Prints timer!&quot; every half-second timer.recur(function() print( timer!&quot;) end, .5) Chaining events To avoid having to deeply nest several functions when creating chains of events, the :after() method can be called on an event returned by timer.delay() . You can keep using the :after() method to create complex timed sequences. -- Prints &quot;cat&quot;, &quot;dog&quot;, then &quot;owl&quot;, waiting 1 second between each print timer.delay(function() print(&quot;cat&quot;) end, 1) :after(function() print(&quot;dog&quot;) end, 1) :after(function() print(&quot;owl&quot;) end, 1) Stopping events An event can be stopped and removed at any point by calling its :stop() method. To do this the event must be assigned to a variable when it is created. -- Create a new event local t = timer.delay(function() print( timer!&quot;) end, 10) -- Remove the event before it has a chance to run t:stop() Groups timer provides the ability to create event groups; these are objects which can have events added to them, and which are in charge of updating and handling their contained events. A group is created by calling the timer.group()` function. local group = timer.group() Once a group is created it acts independently of the timer` object, and must be updated each frame using its own update method. group:update() To add a events to a group, the group's :delay() or :recur() methods should be used. group:delay(function() print(&quot;hello world&quot;) end, 4) A good example of where groups are useful is for games where you may have a set of events which effect objects in the game world and which you want to pause when the game is paused. A group's events can be paused by simply neglecting to call its update() method; when a group is destroyed its events are also destroyed. object The object module offer an interface for OOP programming Creating a new class Point = object:extend() function Point:new(x, y) self.x = x or 0 self.y = y or 0 end Creating a new object local p = Point(10, 20) Extending an existing class Rect = Point:extend() function Rect:new(x, y, width, height) Rect.super.new(self, x, y) self.width = width or 0 self.height = height or 0 end Checking an object's type local p = Point(10, 20) print(p:is(Object)) -- true print(p:is(Point)) -- true print(p:is(Rect)) -- false Using mixins PairPrinter = object:extend() function PairPrinter:printPairs() for k, v in pairs(self) do print(k, v) end end Point = object:extend() Point:implement(PairPrinter) function Point:new(x, y) self.x = x or 0 self.y = y or 0 end local p = Point() p:printPairs() Using static variables Point = object:extend() Point.scale = 2 function Point:new(x, y) self.x = x or 0 self.y = y or 0 end function Point:getScaled() return self.x * Point.scale, self.y * Point.scale end Creating a metamethod function Point:__tostring() return self.x .. &quot;, &quot; .. self.y end Tween The object module offer an interface for tweening Tween creation local t = tween.new(duration, subject, target, [easing]) Creates a new tween. duration means how much the change will take until it's finished. It must be a positive number. subject must be a table with at least one key-value. Its values will be gradually changed by the tween until they look like target . All the values must be numbers, or tables with numbers. target must be a table with at least the same keys as subject . Other keys will be ignored. easing can be either a function or a function name (see the easing section below). It's default value is 'linear' t is the object that must be used to perform the changes - see the \"Tween methods\" section below. This function only creates and returns the tween. It must be captured in a variable and updated via t:update(dt) in order for the changes to take place. Tween methods local complete = t:update() Gradually changes the contents of subject to that it looks more like target as time passes. t is a tween returned by tween.new complete is true if the tween has reached its limit (its internal clock is &gt;= duration ). It is false otherwise. When the tween is complete, the values in subject will be equal to target 's. The way they change over time will depend on the chosen easing function. local complete = t:set(clock) Moves a tween's internal clock to a particular moment. t is a tween returned by tween.new clock is a positive number or 0. It's the new value of the tween's internal clock. complete works like in t:update ; it's true if the tween has reached its end, and false otherwise. If clock is greater than t.duration , then the values in t.subject will be equal to t.target , and t.clock will be equal to t.duration . t:reset() Resets the internal clock of the tween back to 0, resetting subject . t is a tween returned by tween.new This method is equivalent to t:set(0) . Easing functions Easing functions are functions that express how slow/fast the interpolation happens in tween. The easing functions can be found in the table tween.easing . They can be divided into several families: linear is the default interpolation. It's the simplest easing function. quad , cubic , quart , quint , expo , sine and circle are all \"smooth\" curves that will make transitions look natural. The back family starts by moving the interpolation slightly \"backwards\" before moving it forward. The bounce family simulates the motion of an object bouncing. The elastic family simulates inertia in the easing, like an elastic gum. Each family (except linear ) has 4 variants: in starts slow, and accelerates at the end out starts fast, and decelerates at the end inOut starts and ends slow, but it's fast in the middle outIn starts and ends fast, but it's slow in the middle family in out inOut outIn Linear linear linear linear linear Quad inQuad outQuad inOutQuad outInQuad Cubic inCubic outCubic inOutCubic outInCubic Quart inQuart outQuart inOutQuart outInQuart Quint inQuint outQuint inOutQuint outInQuint Expo inExpo outExpo inOutExpo outInExpo Sine inSine outSine inOutSine outInSine Circ inCirc outCirc inOutCirc outInCirc Back inBack outBack inOutBack outInBack Bounce inBounce outBounce inOutBounce outInBounce Elastic inElastic outElastic inOutElastic outInElastic When you specify an easing function, you can either give the function name as a string. The following two are equivalent: local t1 = tween.new(10, subject, {x=10}, tween.easing.linear) local t2 = tween.new(10, subject, {x=10}, 'linear') But since 'linear' is the default, you can also do this: local t3 = tween.new(10, subject, {x=10}) Custom easing functions You are not limited to tween's easing functions; if you pass a function parameter in the easing, it will be used. The passed function will need to take 4 parameters: t (time): starts in 0 and usually moves towards duration b (begin): initial value of the of the property being eased. c (change): ending value of the property - starting value of the property d (duration): total duration of the tween And must return the new value after the interpolation occurs. local cubicbezier = function (x1, y1, x2, y2) local curve = love.math.newBezierCurve(0, 0, x1, y1, x2, y2, 1, 1) return function (t, b, c, d) return c * curve:evaluate(t/d) + b end end local label = { x=200, y=0, text = &quot;hello&quot; } local labelTween = tween.new(4, label, {y=300}, cubicbezier(.35, .97, .58, .61)) Credits Engine written in BlitzMax NG Carts written in Lua 5.1 The graphic library is Raylib Classic by rxi for lua OOP Tween by kikito Tick by rxi Sound Effects by Coffee 'Valen' Bat"
  },
  {
    "title": "Play64 fantasy console",
    "url": "play64/index.html",
    "date": "2025-09-17",
    "content": "Play64 is a fantasy console developed for The Tool Jam 5. It Is a game engine for Gameboy/Atari 2600 games It features a D-pad and two actiown buttons, with a 64 x 64 display capable of rendering four shades of violet. Games are written in Lua 5.1. The console itself is implemented using BlitzMax NG and the Raylib graphics library. Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game × ‹ › Name Size Date Download docs.pdf 137.8 KB 2025-05-14 13:19 Download play64.zip 1.7 MB 2025-05-14 13:22 Download"
  },
  {
    "title": "VectorDefense",
    "url": "VectorDefense/index.html",
    "date": "2025-01-01",
    "content": "VectorDefense English VectorDefense is a tower defense game built with LÖVE in Lua. It features grid-based maps where players defend against waves of enemies using towers. The game utilizes a modular architecture for enemies, towers, puzzles, and more. Note: This project is still in early development and is not fully implemented. Requirements LÖVE 2D game engine (version 11.3 or compatible) How to Run Install LÖVE from love2d.org . Clone or download this repository. Navigate to the project directory. Run love.exe . (Windows) or love . (Linux/Mac). Project Structure src/ : Game logic modules (enemies, towers, maps, etc.) libs/ : External libraries (camera, event, etc.) mod/ : Music and assets Italiano Descrizione VectorDefense è un gioco tower defense costruito con LÖVE in Lua. Il gioco si svolge su mappe basate sulla griglia dove i giocatori devono difendersi contro ondate di nemici usando torri. Il gioco utilizza un'architettura modulare per nemici, torri, puzzle e altro. Nota: Questo progetto è ancora in sviluppo precoce (\"in alto mare\") e non è completamente implementato. Requisiti Motore di gioco LÖVE 2D (versione 11.3 o compatibile) Come Eseguire Installa LÖVE da love2d.org . Clona o scarica questo repository. Naviga nella directory del progetto. Esegui love.exe . (Windows) o love . (Linux/Mac). Struttura del Progetto src/ : Moduli di logica di gioco (nemici, torri, mappe, ecc.) libs/ : Librerie esterne (camera, evento, ecc.) mod/ : Musica e risorse Come Eseguire Installa LÖVE da love2d.org . Clona o scarica questo repository. Naviga nella directory del progetto. Esegui love.exe . (Windows) o love . (Linux/Mac). Struttura del Progetto src/ : Moduli di logica di gioco (nemici, torri, mappe, ecc.) libs/ : Librerie esterne (camera, evento, ecc.) mod/ : Musica e risorse × ‹ ›"
  },
  {
    "title": "docs",
    "url": "vibegui/docs.html",
    "date": null,
    "content": "Vibe GUI - Full Documentation This document contains the complete technical documentation for Vibe GUI library for LOVE2D. For a quick start guide, see README.md . Table of Contents API Reference Distribution &amp; Packaging Examples Migration Guide Developer Experience Requirements &amp; Setup Contributing License API Reference Core Initialization GUI.init(config) Initializes the GUI system with enhanced configuration options. Parameters: - config.theme - Theme name (default: \"eighties_terminal\") - config.language - Language code (default: \"en\") - config.toast - Toast position config {position: \"top-right\"|\"bottom-left\"|...} - config.global - Export globals for backward compatibility (default: false) - config.components - Auto-load core components (default: true) Returns: GUI instance local GUI = require(&quot;gui&quot;) GUI.init({ theme = &quot;eighties_terminal&quot;, language = &quot;en&quot;, toast = {position = &quot;top-right&quot;}, global = true -- Optional: export SceneManager, ToastManager as globals }) Component System GUI.createComponent(type, params) Creates any component by its string name with standardized parameters. Parameters: - type (string) - Component type (\"button\", \"text\", \"slider\", etc.) - params (table) - Component-specific parameters Returns: Component instance or nil All Components Support: - x, y : Position coordinates - width, height : Dimensions - visible : Boolean visibility toggle - theme : Override theme for this component -- Button with all standard parameters local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click Me!&quot;, theme = &quot;light_theme&quot;, action = function() print(&quot;Clicked!&quot;) end }) -- Supported component types: button, text, slider, image, panel, toast, tooltip, -- animatedText, textButton, editableText, filePicker GUI.ComponentFactory:register(type, class) Dynamically register custom components at runtime. Parameters: - type (string) - New component type name - class (table) - Component class with constructor and methods -- Define custom component local ProgressBar = Class:extend() function ProgressBar:new(x, y, width, height) self.x, self.y, self.width, self.height = x, y, width, height self.progress = 0 end function ProgressBar:draw() -- Implementation end -- Register it GUI.ComponentFactory:register(&quot;progressbar&quot;, ProgressBar) GUI.ComponentFactory.paramMaps[&quot;progressbar&quot;] = {&quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;} -- Now use it anywhere! local pb = GUI.createComponent(&quot;progressbar&quot;, {x=100, y=100, width=300, height=30}) GUI.ComponentFactory:getRegisteredTypes() Returns array of all available component types. Returns: Table of component type strings Preset System GUI.createPreset(name, overrides) Create UI templates with component groups and layouts. Parameters: - name (string) - Preset name (\"dialog\", \"menu\", \"settingItem\", etc.) - overrides (table) - Override default preset parameters Returns: Table containing created component instances -- Built-in presets local dialog = GUI.createPreset(&quot;dialog&quot;, { title = {text = &quot;Confirmation&quot;}, content = {text = &quot;Are you sure?&quot;}, buttonContainer = { okBtn = {action = function() print(&quot;OK&quot;) end}, cancelBtn = {action = function() print(&quot;Cancel&quot;) end} } }) local settings = GUI.createPreset(&quot;settingItem&quot;, { label = {text = &quot;Volume&quot;}, slider = {rangeMax = 100} }) GUI.PresetManager:registerComponentPreset(name, config) Register new reusable UI templates. Parameters: - name (string) - Preset identifier - config (table) - Preset configuration with component definitions GUI.PresetManager:getComponentPresetNames() Returns array of all registered preset names. Returns: Table of preset name strings Animation System GUI.animate(component, presetName, options) Apply professional animations to any component using presets. Parameters: - component - Target GUI component - presetName (string) - Animation preset (\"button.success\", \"slider.focus\", etc.) - options (table) - Animation options (optional) Returns: Animation ID for control -- 35+ Built-in Animation Presets Available: -- Button animations GUI.animate(button, &quot;button.success&quot;) -- Green success ripple GUI.animate(button, &quot;button.error&quot;) -- Red shake animation GUI.animate(button, &quot;button.pulse&quot;) -- Attention pulse -- Slider animations GUI.animate(slider, &quot;slider.focus&quot;) -- Focus highlight GUI.animate(slider, &quot;slider.snap&quot;) -- Value snap feedback -- Panel layouts GUI.animate(panel, &quot;panel.fade&quot;) -- Fade in/out GUI.animate(panel, &quot;panel.slide&quot;) -- Slide from direction -- Multiple animations at once GUI.animate(component, &quot;button.success&quot;) GUI.stopAnimation(animId) -- Stop specific animation GUI.stopAllAnimations() -- Emergency stop Theme &amp; Styling System GUI.switchTheme(themeName, options) Switch between themes at runtime with optional transitions. Parameters: - themeName (string) - Target theme name - options (table) - Transition options Returns: Boolean success -- Runtime theme switching GUI.switchTheme(&quot;light_theme&quot;, { transition = &quot;fade&quot;, duration = 0.8 }) -- Check status if GUI.isTransitioning() then print(&quot;Theme transition in progress&quot;) end -- Preview without committing GUI.previewTheme(&quot;neon_theme&quot;) GUI.commitTheme() -- or GUI.discardTheme() GUI.StyleManager:loadTheme(themeName) Load theme from JSON or Lua file. GUI.getCurrentTheme() Returns currently active theme name. Returns: String theme name GUI.getAvailableThemes() Returns array of available theme names. Returns: Table of theme name strings Template Serialization System GUI.saveTemplate(templateName, component, options) Save components or component hierarchies as templates. Parameters: - templateName (string) - Unique template identifier - component - Component to save (can be single or hierarchy) - options (table) - Metadata and configuration Returns: Boolean success -- Save complete UI forms local form = createUserRegistrationForm() GUI.saveTemplate(&quot;UserRegForm&quot;, form, { category = &quot;components&quot;, author = &quot;DevTeam&quot;, description = &quot;User registration form v1.0&quot;, tags = {&quot;forms&quot;, &quot;user-input&quot;, &quot;registration&quot;} }) GUI.loadTemplate(templateName, options) Load and instantiate templates from disk. Parameters: - templateName (string) - Template to load - options (table) - Loading options Returns: Instantiated component or nil -- Load and use template local loadedForm = GUI.loadTemplate(&quot;UserRegForm&quot;, { restoreEventHandlers = false, -- Security option connectToStyles = true -- Apply current theme }) -- Position and use loadedForm.x = 100 loadedForm.y = 200 loadedForm:draw() -- Ready to use GUI.createFromTemplate(templateName, options) Convenience method combining load and positioning. Parameters: - templateName (string) - Template identifier - options (table) - x,y position and other options Returns: Positioned component ready for use GUI.exportTemplate(templateName, format, filename) Export templates for cross-project sharing. Supported Formats: JSON (human-readable), Lua (direct code) Cross-Platform: Import with GUI.importTemplate() Plugin System GUI.loadPlugin(pluginName) Load external component plugins. Parameters: - pluginName (string) - Plugin identifier -- Load plugins for extended functionality GUI.loadPlugin(&quot;advanced_controls&quot;) GUI.loadPlugin(&quot;charts_and_graphs&quot;) print(&quot;Loaded plugins: &quot; .. table.concat(GUI.getLoadedPlugins(), &quot;, &quot;)) GUI.getLoadedPlugins() Returns array of currently loaded plugin names. GUI.getAvailablePlugins() Returns array of discoverable plugin names. Advanced Scene &amp; Layout Management GUI.createScene(name, config) Create complex screen layouts using preset system. Parameters: - name (string) - Scene preset name - config (table) - Scene configuration overrides -- Scene presets available: &quot;menuScene&quot;, &quot;dialogScene&quot;, &quot;settingsScene&quot; local mainMenu = GUI.createScene(&quot;menuScene&quot;, { title = {text = &quot;My Game&quot;}, menuItems = { play = {action = startGame}, options = {action = showOptions}, exit = {action = love.event.quit} } }) Utility Functions GUI.update(dt) Update timing-dependent systems (animations, theme transitions). Parameters: - dt (number) - Delta time from LOVE2D Usage: Call in love.update(dt) GUI.getClass() Returns the OOP base class for component development. Returns: Class constructor local Class = GUI.getClass() local MyComponent = Class:extend() function MyComponent:new(x, y) self.x, self.y = x, y end Global Managers Access GUI.SceneManager : Scene transition management GUI.StyleManager : Theme and style coordination GUI.ToastManager : Notification system GUI.i18n : Internationalization system GUI.SoundSystem : Audio feedback system GUI.ComponentFactory : Component creation factory Advanced Features Reference Complete Component List button - Interactive buttons with states text - Text display with alignment, shadows, outlines slider - Value selectors with tooltips image - Image display with scaling, tinting panel - Containers with scrollbars, clipping toast - Notifications with auto-dismiss tooltip - Floating help text animatedText - Text with typewriter effects textButton - Text-only clickable buttons editableText - Single-line text input filePicker - File selection dialogs Custom components via plugin system Built-in Preset Categories Layout Presets : dialog , menu , notification Component Presets : formField , settingItem , toolbar Scene Presets : menuScene , dialogScene , settingsScene Supported Events (All Components) mousepressed(x, y, button) mousemoved(x, y, dx, dy) mousereleased(x, y, button) keypressed(key, isrepeat) textinput(text) update(dt) This library provides professional-grade UI capabilities with 100+ functions across all major systems, supporting custom extensibility through plugins and templates for maximum developer flexibility. Distribution &amp; Packaging The library supports multiple distribution methods depending on your project's needs: As a LOVE2D Game Component Best for: Single-game projects, game jams, complete game bundles Copy the library into your game's structure: my-game/ ├── main.lua # Your game code ├── gui/ # Copy entire gui/ folder │ ├── init.lua │ ├── components/ │ ├── themes/ │ └── ... ├── assets/ # Your game assets └── conf.lua Use in your main.lua : ```lua local GUI = require(\"gui\") function love.load() GUI.init({theme = \"eighties_terminal\"}) -- Create your UI... end ``` Package as .love file : bash zip -r my-game.love * As a Reusable Library Best for: Multiple projects, team development, library distribution Option 1: LOVE2D Shared Location Install globally in LOVE2D directory: ``` # On Windows C:\\Users\\YOUR_NAME\\AppData\\Roaming\\LOVE\\gui\\ # Copy entire gui/ folder to this location ``` Use in any project : lua -- Will automatically find gui/ in LOVE directory local GUI = require(\"gui\") Option 2: Version Controlled Library Structure your repo : ├── lib/ │ └── gui/ # GUI library ├── shared/ │ └── gui/ # Symlink to lib/gui/ └── projects/ ├── game1/ ├── game2/ └── ... Update shared link when library updates Minimal Distribution Best for: Small projects, embedded systems, resource-constrained environments Use only core components : lua GUI.init({ components = {\"button\", \"text\", \"panel\"}, -- Only load what you need plugins = false -- Disable plugin system }) Create custom minimal build : - Strip unused themes - Remove documentation assets - Compress textures Cross-Platform Distribution For all platforms LOVE2D supports (Windows, macOS, Linux, Android, iOS): Develop on desktop first - easier debugging Test touch events on target devices Theme optimization for different screen DPI Asset optimization for mobile bandwidth/storage Advanced Integration Patterns NPM-style Package Management Create a simple package.json equivalent: -- gui_package.lua return { name = &quot;vibe-gui&quot;, version = &quot;1.0.0&quot;, description = &quot;Modern GUI library for LOVE2D&quot;, main = &quot;gui/init.lua&quot;, dependencies = { flux = &quot;&gt;=1.0.0&quot;, classic = &quot;&gt;=1.0.0&quot; }, author = &quot;GUI Team&quot;, license = &quot;MIT&quot; } CI/CD Pipeline Integration # .github/workflows/release.yml name: Release GUI Library on: push: tags: ['v*'] jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Create Release Archive run: | zip -r vibe-gui-${{ github.ref_name }}.zip gui/ - name: Upload Release uses: actions/upload-release-asset@v1 with: upload_url: ${{ github.event.release.upload_url }} asset_path: vibe-gui-${{ github.ref_name }}.zip Using with Build Tools Makefile Distribution GUI_VERSION=1.0.0 gui-dist: clean mkdir -p dist/vibe-gui-$(GUI_VERSION) cp -r gui/ dist/vibe-gui-$(GUI_VERSION)/ cp README.md LICENSE.txt dist/vibe-gui-$(GUI_VERSION)/ cd dist &amp;&amp; zip -r vibe-gui-$(GUI_VERSION).zip vibe-gui-$(GUI_VERSION)/ CMake Integration (for complex projects) # CMakeLists.txt cmake_minimum_required(VERSION 3.0) project(MyGame) # Add GUI library add_subdirectory(lib/gui) # Link to your game target_link_libraries(my_game vibe_gui) Performance Optimization Bundle Analysis : See what's included lua print(\"Components loaded: \" .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), \", \")) print(\"Themes available: \" .. table.concat(GUI.getAvailableThemes(), \", \")) Selective Loading : lua -- Only load what you need local config = { loadOnly = {\"button\", \"text\", \"slider\"}, -- Custom filter skipLoaders = {\"plugins\", \"extra_themes\"} -- Skip heavy features } Memory Management : - Templates auto-save/load to reduce memory - Canvas recycling for performance - Lazy component loading Testing Your Distribution Use the included examples to validate your distribution: # Test minimal example e:\\LOVE\\love.exe examples/simple_gui.lua # Test advanced features e:\\LOVE\\love.exe examples/animation_gallery.lua # Test template system e:\\LOVE\\love.exe examples/template_demo.lua Contributing Back When contributing to the library: Follow existing structure in gui/ folder Update package.json if adding dependencies Test distribution in multiple environments Update version in both main.lua and package file This ensures the library remains easily distributable and maintainable for the LOVE2D community. Examples The library includes 7 comprehensive examples demonstrating different use cases: Core Examples simple_gui.lua - Entry-level component creation and basic interactions advanced_usage.lua - Custom components, preset creation, and advanced patterns Feature-Specific Examples animation_gallery.lua - Complete interactive demo of 35+ animation presets layout_demo.lua - Advanced layout strategies (Grid, Flex, Flow layouts) plugin_demo.lua - Loading external plugins and extending functionality template_demo.lua - Template saving/loading with interactive management theme_switcher_demo.lua - Runtime theme switching and visual comparisons Quick Start Examples Testing Your Installation # Run the basic demo e:\\LOVE\\love.exe examples/simple_gui.lua # See all animation capabilities e:\\LOVE\\love.exe examples/animation_gallery.lua # Test template system e:\\LOVE\\love.exe examples/template_demo.lua Minimal Integration Example -- Install GUI globally in %APPDATA%\\LOVE\\gui\\ local GUI = require(&quot;gui&quot;) function love.load() GUI.init({theme = &quot;eighties_terminal&quot;}) local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, text = &quot;Hello!&quot;, action = function() toastManager:add({text = &quot;Welcome to Vibe GUI!&quot;}) end }) self.button = btn end -- ... rest of LOVE2D callbacks Example Project Templates Game Menu System -- Based on template_demo.lua pattern local GUI = require(&quot;gui&quot;) function createMainMenu() return GUI.createPreset(&quot;menu&quot;, { title = {text = &quot;My Awesome Game&quot;}, button1 = {text = &quot;Start Game&quot;, action = startGame}, button2 = {text = &quot;Options&quot;, action = showOptions}, button3 = {text = &quot;Exit&quot;, action = love.event.quit} }) end Settings Panel -- Based on advanced_usage.lua pattern local GUI = require(&quot;gui&quot;) function createSettingsPanel() return GUI.createPreset(&quot;dialog&quot;, { title = {text = &quot;Settings&quot;}, content = {text = &quot;Adjust your preferences:&quot;}, -- Volume slider (from settingItem preset) volumeSection = { type = &quot;settingItem&quot;, label = {text = &quot;Master Volume:&quot;}, slider = {rangeMax = 100} }, -- Fullscreen toggle fullscreenBtn = {action = toggleFullscreen} }) end Real-World Usage Patterns See the examples for full implementations of these patterns: Form Handling : Complete user registration forms with validation Dynamic Content : Real-time updates and state management Component Composition : Building complex UI from simple components Resource Management : Loading/unloading assets as needed Cross-Device Adaptation : Responsive layouts for different screen sizes Migration Guide From Manual Requires Old approach: local Button = require(&quot;gui.components.button&quot;) local button = Button(100, 100, &quot;Click&quot;, 200, 50, function() end) New modular approach: local button = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click&quot;, action = function() end }) Backward Compatibility The library maintains backward compatibility - you can still manually require and use components directly if needed, but the new factory approach is recommended for better modularity. Developer Experience Troubleshooting Common Issues Component Not Drawing -- Issue: Your component isn't showing up function love.draw() -- Do you call love.graphics.clear() BEFORE drawing? love.graphics.clear(0.1, 0.1, 0.15) -- Did you call component:draw()? myButton:draw() -- Is your component positioned within screen bounds? print(myButton.x, myButton.y) -- Debug coordinates end Event Handler Not Working -- Issue: Button clicks aren't registering local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click me&quot;, action = function() print(&quot;Button pressed!&quot;) -- This should work end }) function love.mousepressed(x, y, button) btn:mousepressed(x, y, button) -- Don't forget this! end Animations Not Playing -- Issue: GUI.animate() isn't working function love.load() GUI.init({ theme = &quot;eighties_terminal&quot; -- The AnimationPresets system auto-initializes }) -- This should work AUTOMATICALLY now GUI.animate(myComponent, &quot;button.success&quot;) end function love.update(dt) GUI.update(dt) -- REQUIRED for animations to work! end Template Save/Load Issues -- Common template problems print(&quot;Available templates: &quot; .. table.concat(GUI.listTemplates(), &quot;, &quot;)) -- Template not loading? local success = GUI.saveTemplate(&quot;test&quot;, component, { category = &quot;components&quot; -- Required field }) -- Template path conflicts? GUI.TemplateSerializer:setTemplateDir(&quot;my/templates/&quot;) -- Custom location Plugin Loading Failures -- Debug plugin issues print(&quot;Looking for plugins in: &quot; .. GUI.getPluginPath()) -- Plugin discovery issues? print(&quot;Found plugins: &quot; .. table.concat(GUI.getAvailablePlugins(), &quot;, &quot;)) -- Try explicit path GUI.PluginSystem:addPluginPath(&quot;my/custom/plugins/&quot;) Performance Optimization Selective Component Loading -- Only load what you need GUI.init({ components = {&quot;button&quot;, &quot;text&quot;, &quot;slider&quot;} -- Skip unused components }) -- Check what's loaded print(&quot;Loaded components: &quot; .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), &quot;, &quot;)) Canvas Optimization -- Enable canvas optimization for panels (already enabled by default) local panel = GUI.createComponent(&quot;panel&quot;, { x = 100, y = 100, width = 400, height = 300, -- Canvas rendering is automatic for performance }) -- Manual canvas control if needed panel:setCanvasEnabled(true) -- Faster rendering, higher memory panel:setCanvasEnabled(false) -- Slower but less memory Animation Performance -- Stop animations when not needed GUI.stopAllAnimations() -- Emergency cleanup -- Limit concurrent animations local animationCount = GUI.AnimationPresets:getActiveAnimationCount() if animationCount &gt; 10 then GUI.stopOldestAnimation() end Theme Optimization -- Preload themes to avoid runtime switching costs GUI.StyleManager:loadTheme(&quot;retro&quot;) GUI.StyleManager:loadTheme(&quot;modern&quot;) -- Switch instantly without transitions GUI.switchTheme(&quot;retro&quot;, {transition = &quot;none&quot;}) Memory Management Template Caching -- Templates are cached for performance local template = GUI.loadTemplate(&quot;form&quot;) -- First load -- Subsequent loads return cached copy local instance2 = GUI.loadTemplate(&quot;form&quot;) -- Instant Component Cleanup -- Proper component cleanup function cleanupScreen() -- Stop animations GUI.stopAllAnimations() -- Clear templates if needed GUI.TemplateSerializer:clearCache() -- Remove event handlers for _, component in ipairs(myComponents) do component.action = nil -- Remove callbacks end end Resource Monitoring -- Debug memory usage print(&quot;Templates in memory: &quot; .. GUI.TemplateSerializer:getCacheSize()) print(&quot;Active animations: &quot; .. GUI.AnimationPresets:getActiveAnimationCount()) print(&quot;Loaded plugins: &quot; .. #GUI.getLoadedPlugins()) -- Clean up periodically if math.random() &lt; 0.1 then -- 10% chance each frame GUI.TemplateSerializer:cleanupLRU() -- Remove least recently used end Best Practices Component Organization function createUIScreen() -- Group related components local ui = { header = createHeader(), content = createContentArea(), footer = createFooter() } -- Store references for cleanup self.currentUI = ui return ui end function cleanupScreen() if self.currentUI then GUI.stopAnimationsInGroup(self.currentUI) self.currentUI = nil end end Event Handler Management local handlers = {} function setupEventHandlers() -- Store handler references handlers.button1 = function() print(&quot;Button 1&quot;) end handlers.button2 = function() print(&quot;Button 2&quot;) end local btn1 = GUI.createComponent(&quot;button&quot;, { text = &quot;Button 1&quot;, action = handlers.button1 }) local btn2 = GUI.createComponent(&quot;button&quot;, { text = &quot;Button 2&quot;, action = handlers.button2 }) return {btn1, btn2} end function cleanupEventHandlers() -- Clear all handlers to prevent memory leaks for k, v in pairs(handlers) do handlers[k] = nil end end Error Handling -- Safe component creation function createWithFallback(type, params, fallbackType) local component, success = pcall(GUI.createComponent, type, params) if not success then print(&quot;Failed to create &quot; .. type .. &quot;, using fallback&quot;) component = GUI.createComponent(fallbackType, params) end return component end -- Template loading with error handling local template, success = pcall(GUI.loadTemplate, &quot;user_form&quot;) if not success then print(&quot;Template not found, creating default&quot;) template = createDefaultForm() end Theme Compatibility -- Ensure theme compatibility function applyThemeSafely(themeName) if GUI.StyleManager:themeExists(themeName) then GUI.switchTheme(themeName) else print(&quot;Theme &quot; .. themeName .. &quot; not found, using default&quot;) GUI.switchTheme(&quot;eighties_terminal&quot;) end end Development Workflow Hot Reloading Support -- For development - reload components without restart function developmentReload() if love.keyboard.isDown(&quot;r&quot;) and love.keyboard.isDown(&quot;ctrl&quot;) then print(&quot;Reloading GUI...&quot;) package.loaded[&quot;gui&quot;] = nil GUI = require(&quot;gui&quot;) GUI.init() -- Reinitialize end end Debug Overlay function debugOverlay() local debugInfo = { &quot;FPS: &quot; .. tostring(love.timer.getFPS()), &quot;Components: &quot; .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), &quot;, &quot;), &quot;Themes: &quot; .. table.concat(GUI.getAvailableThemes(), &quot;, &quot;), &quot;Templates: &quot; .. #GUI.listTemplates(), &quot;Memory: &quot; .. collectgarbage(&quot;count&quot;) .. &quot;KB&quot; } love.graphics.setColor(0, 0, 0, 0.5) love.graphics.rectangle(&quot;fill&quot;, 10, 10, 300, #debugInfo * 20 + 10) love.graphics.setColor(1, 1, 1) for i, info in ipairs(debugInfo) do love.graphics.print(info, 20, 20 + i * 20) end end Cross-Platform Considerations Mobile Considerations -- Detect mobile platforms local isMobile = love.system.getOS() == &quot;Android&quot; or love.system.getOS() == &quot;iOS&quot; if isMobile then -- Larger touch targets buttonSize = 60 -- Enable touch-friendly gestures end -- Platform-specific optimizations if love.system.getOS() == &quot;Android&quot; then -- Android-specific settings love.window.setMode(0, 0, {resizable = false}) end Desktop Considerations -- Desktop mouse/keyboard optimizations function love.wheelmoved(x, y) local mouseX, mouseY = love.mouse.getPosition() -- Panel scrolling if myPanel:isMouseOver(mouseX, mouseY) then myPanel:scroll(0, y * 20) -- Scroll panels end end This developer guide covers 90% of common issues and provides battle-tested patterns for production use. Requirements &amp; Setup System Requirements LOVE2D : 11.0+ Required Dependencies : flux (animation library) classic (OOP library) Optional Dependencies : Additional asset files for themes Audio dependencies for sound effects Installation Methods Method 1: Copy to Project # Copy the gui/ folder to your project cp -r gui/ my-project/ # Use in your main.lua local GUI = require(&quot;gui&quot;) Method 2: LOVE2D Global Installation # On Windows - copy to LOVE directory # C:\\Users\\YOUR_NAME\\AppData\\Roaming\\LOVE\\gui\\ # Then use anywhere local GUI = require(&quot;gui&quot;) Method 3: Git Submodule git submodule add https://github.com/your-repo/vibe-gui.git lib/gui Verification # Test installation love examples/simple_gui.lua Contributing To add new components: 1. Create the component in gui/components/ 2. Register it in ComponentFactory:init() 3. Add parameter mapping if needed 4. Update this documentation 5. Add examples if applicable Development Setup # Clone the repository git clone https://github.com/your-repo/vibe-gui.git # Run tests love main.lua Code Style Follow existing component patterns Add LuaDoc comments to all public methods Test with multiple themes Ensure backward compatibility License This project is open source under the MIT license. See LICENSE.txt for details. ⬅️ Back to README.md | 📚 Table of Contents"
  },
  {
    "title": "index",
    "url": "vibegui/index.html",
    "date": null,
    "content": "Vibe GUI for LOVE2D A modern, feature-rich GUI library for LOVE2D featuring professional UI components, animations, themes, and extensible architecture. Perfect for games and applications requiring polished user interfaces. ⚡ Quick Start Installation Copy the gui/ folder to your LOVE2D project directory Add to your main.lua: local GUI = require(&quot;gui&quot;) function love.load() GUI.init({ theme = &quot;eighties_terminal&quot;, language = &quot;en&quot; }) -- Create a button using the factory local button = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click Me!&quot;, action = function() toastManager:add({text = &quot;Button clicked!&quot;}) end }) self.button = button end function love.update(dt) self.button:update(dt) GUI.SceneManager:update(dt) toastManager:update(dt) end function love.draw() love.graphics.clear(0.1, 0.1, 0.15) self.button:draw() GUI.SceneManager:drawFade() toastManager:draw() end Test Your Setup # Run included examples e:\\LOVE\\love.exe examples/simple_gui.lua 📚 Key Features 🔧 Component Factory : Create UI by name ( GUI.createComponent(\"button\", {...}) ) 🎨 Preset System : Ready-made UI templates ( GUI.createPreset(\"dialog\", {...}) ) ✨ Animation Engine : 35+ professional effects 🎭 Dynamic Themes : Runtime theme switching with transitions 💾 Template System : Save/load complete UI layouts 🔌 Plugin Architecture : Easily extensible 📱 Cross-Platform : All LOVE2D platforms supported 📖 Documentation 📚 View Complete Documentation Includes comprehensive API reference, advanced examples, distribution guides, troubleshooting, and best practices. Requirements ❤️‍🔥 LOVE2D : 11.0+ 🔧 Required dependencies : flux, classic OOP library 🎨 Optional : Additional theme assets License 📄 MIT License - See LICENSE.txt for details. function love.load() -- Initialize the GUI system local config = { theme = \"eighties_terminal\", language = \"en\", toast = { position = \"bottom-right\" } } GUI.init(config) -- Create a button using the factory local button = GUI.createComponent(\"button\", { x = 100, y = 100, width = 200, height = 50, text = \"Click Me!\", action = function() toastManager:add({text = \"Hello World!\", duration = 2}) end }) -- Store for updating/drawing self.button = button end function love.update(dt) self.button:update(dt) GUI.SceneManager:update(dt) toastManager:update(dt) end function love.draw() love.graphics.clear(0.1, 0.1, 0.15) self.button:draw() GUI.SceneManager:drawFade() toastManager:draw() end function love.mousepressed(x, y, button) self.button:mousepressed(x, y, button) end ## Core Concepts ### Modular Architecture The library is organized into several key modules: - `gui/init.lua` - Main entry point and initialization - `gui/ComponentFactory.lua` - Creates components by type string - `gui/PresetManager.lua` - Manages UI presets and templates - `gui/StyleManager.lua` - Handles theming and styling - `gui/SceneManager.lua` - Manages scene transitions - `gui/ToastManager.lua` - Notification system - Components in `gui/components/` - Individual UI elements - Scenes in `gui/scenes/` - Full screens/interfaces ## Component Factory Create any component by its string name with standardized parameters: ```lua -- Create a text label local label = GUI.createComponent(&quot;text&quot;, { x = 50, y = 100, width = 300, height = 50, align = &quot;center&quot;, text = &quot;Hello World&quot; }) -- Create a slider local slider = GUI.createComponent(&quot;slider&quot;, { x = 100, y = 200, width = 200, height = 20, rangeMin = 0, rangeMax = 100, callback = function(value) print(&quot;Volume:&quot;, value) end }) -- Create a button local button = GUI.createComponent(&quot;button&quot;, { x = 150, y = 250, width = 120, height = 40, text = &quot;OK&quot;, action = function() print(&quot;Button pressed!&quot;) end }) Available Component Types button - Interactive button with hover/pressed states text - Text display with formatting options slider - Draggable value selector image - Image display component panel - Rectangular container/panel toast - Notification message tooltip - Floating help text animatedText - Animated text display textButton - Text-only button editableText - Text input field filePicker - File selection dialog Custom components (via registration) Presets Use pre-built UI patterns and templates: -- Create a dialog preset local dialog = GUI.createPreset(&quot;dialog&quot;, { title = {text = &quot;Confirmation&quot;, width = 0.8}, content = { text = &quot;Are you sure you want to continue?&quot;, width = 0.8, height = 150 }, buttonContainer = { -- Override default button container } }) -- Create a settings item (label + slider) local volumeControl = GUI.createPreset(&quot;settingItem&quot;, { label = {text = &quot;Sound Volume&quot;}, slider = { rangeMax = 100, callback = function(v) setVolume(v) end } }) Built-in Component Presets dialog - Modal dialog with title, content, and buttons menu - Centered menu with title and button collection formField - Label and input field pair settingItem - Label and slider for settings Scene Presets menuScene - Basic menu layout dialogScene - Modal overlay layout settingsScene - Panel-based settings page Custom Components Creating Custom Components -- Define your component class local ProgressBar = Class:extend() function ProgressBar:new(x, y, width, height, color) self.x, self.y, self.width, self.height = x, y, width, height self.color = color or {0.2, 0.8, 0.3} self.progress = 0 end function ProgressBar:draw() -- Draw background love.graphics.setColor(0.3, 0.3, 0.3) love.graphics.rectangle(&quot;fill&quot;, self.x, self.y, self.width, self.height) -- Draw progress local fillWidth = (self.progress / 100) * self.width love.graphics.setColor(self.color) love.graphics.rectangle(&quot;fill&quot;, self.x, self.y, fillWidth, self.height) end -- Register the component GUI.ComponentFactory:register(&quot;progressbar&quot;, ProgressBar) -- Add parameter mapping GUI.ComponentFactory.paramMaps[&quot;progressbar&quot;] = {&quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;, &quot;color&quot;} -- Now use it local pb = GUI.createComponent(&quot;progressbar&quot;, { x = 100, y = 100, width = 300, height = 30, color = {0.8, 0.3, 0.1} }) Custom Presets -- Register a custom preset GUI.PresetManager:registerComponentPreset(&quot;loading_screen&quot;, { spinner = { type = &quot;progressbar&quot;, width = 0.8, height = 20, y = 50 }, message = { type = &quot;text&quot;, align = &quot;center&quot;, height = 30, y = 80, text = &quot;Loading...&quot; }, cancel = { type = &quot;button&quot;, width = 100, height = 35, y = 120, text = &quot;Cancel&quot; } }) -- Use the custom preset local loading = GUI.createPreset(&quot;loading_screen&quot;, { message = {text = &quot;Downloading update...&quot;}, cancel = {action = function() cancelDownload() end} }) Styling and Themes The library uses a theme-based styling system: -- Load a theme GUI.StyleManager:loadTheme(&quot;eighties_terminal&quot;) GUI.StyleManager:notifyStyleChange() -- Apply to all components -- Get current style local style = GUI.StyleManager:getStyle() -- Direct style access style.button.background_color = {1, 0, 0} -- Change all buttons to red style.gui.shadow.enabled = false -- Disable shadows globally Available Themes eighties_terminal - Retro terminal styling Custom themes can be loaded from JSON/Lua files API Reference Core Initialization GUI.init(config) Initializes the GUI system with enhanced configuration options. Parameters: - config.theme - Theme name (default: \"eighties_terminal\") - config.language - Language code (default: \"en\") - config.toast - Toast position config {position: \"top-right\"|\"bottom-left\"|...} - config.global - Export globals for backward compatibility (default: false) - config.components - Auto-load core components (default: true) Returns: GUI instance local GUI = require(&quot;gui&quot;) GUI.init({ theme = &quot;eighties_terminal&quot;, language = &quot;en&quot;, toast = {position = &quot;top-right&quot;}, global = true -- Optional: export SceneManager, ToastManager as globals }) Component System GUI.createComponent(type, params) Creates any component by its string name with standardized parameters. Parameters: - type (string) - Component type (\"button\", \"text\", \"slider\", etc.) - params (table) - Component-specific parameters Returns: Component instance or nil All Components Support: - x, y : Position coordinates - width, height : Dimensions - visible : Boolean visibility toggle - theme : Override theme for this component -- Button with all standard parameters local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click Me!&quot;, theme = &quot;light_theme&quot;, action = function() print(&quot;Clicked!&quot;) end }) -- Supported component types: button, text, slider, image, panel, toast, tooltip, -- animatedText, textButton, editableText, filePicker GUI.ComponentFactory:register(type, class) Dynamically register custom components at runtime. Parameters: - type (string) - New component type name - class (table) - Component class with constructor and methods -- Define custom component local ProgressBar = Class:extend() function ProgressBar:new(x, y, width, height) self.x, self.y, self.width, self.height = x, y, width, height self.progress = 0 end function ProgressBar:draw() -- Implementation end -- Register it GUI.ComponentFactory:register(&quot;progressbar&quot;, ProgressBar) GUI.ComponentFactory.paramMaps[&quot;progressbar&quot;] = {&quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;} -- Now use it anywhere! local pb = GUI.createComponent(&quot;progressbar&quot;, {x=100, y=100, width=300, height=30}) GUI.ComponentFactory:getRegisteredTypes() Returns array of all available component types. Returns: Table of component type strings Preset System GUI.createPreset(name, overrides) Create UI templates with component groups and layouts. Parameters: - name (string) - Preset name (\"dialog\", \"menu\", \"settingItem\", etc.) - overrides (table) - Override default preset parameters Returns: Table containing created component instances -- Built-in presets local dialog = GUI.createPreset(&quot;dialog&quot;, { title = {text = &quot;Confirmation&quot;}, content = {text = &quot;Are you sure?&quot;}, buttonContainer = { okBtn = {action = function() print(&quot;OK&quot;) end}, cancelBtn = {action = function() print(&quot;Cancel&quot;) end} } }) local settings = GUI.createPreset(&quot;settingItem&quot;, { label = {text = &quot;Volume&quot;}, slider = {rangeMax = 100} }) GUI.PresetManager:registerComponentPreset(name, config) Register new reusable UI templates. Parameters: - name (string) - Preset identifier - config (table) - Preset configuration with component definitions GUI.PresetManager:getComponentPresetNames() Returns array of all registered preset names. Returns: Table of preset name strings Animation System GUI.animate(component, presetName, options) Apply professional animations to any component using presets. Parameters: - component - Target GUI component - presetName (string) - Animation preset (\"button.success\", \"slider.focus\", etc.) - options (table) - Animation options (optional) Returns: Animation ID for control -- 35+ Built-in Animation Presets Available: -- Button animations GUI.animate(button, &quot;button.success&quot;) -- Green success ripple GUI.animate(button, &quot;button.error&quot;) -- Red shake animation GUI.animate(button, &quot;button.pulse&quot;) -- Attention pulse -- Slider animations GUI.animate(slider, &quot;slider.focus&quot;) -- Focus highlight GUI.animate(slider, &quot;slider.snap&quot;) -- Value snap feedback -- Panel layouts GUI.animate(panel, &quot;panel.fade&quot;) -- Fade in/out GUI.animate(panel, &quot;panel.slide&quot;) -- Slide from direction -- Multiple animations at once GUI.animate(component, &quot;button.success&quot;) GUI.stopAnimation(animId) -- Stop specific animation GUI.stopAllAnimations() -- Emergency stop Theme &amp; Styling System GUI.switchTheme(themeName, options) Switch between themes at runtime with optional transitions. Parameters: - themeName (string) - Target theme name - options (table) - Transition options Returns: Boolean success -- Runtime theme switching GUI.switchTheme(&quot;light_theme&quot;, { transition = &quot;fade&quot;, duration = 0.8 }) -- Check status if GUI.isTransitioning() then print(&quot;Theme transition in progress&quot;) end -- Preview without committing GUI.previewTheme(&quot;neon_theme&quot;) GUI.commitTheme() -- or GUI.discardTheme() GUI.StyleManager:loadTheme(themeName) Load theme from JSON or Lua file. GUI.getCurrentTheme() Returns currently active theme name. Returns: String theme name GUI.getAvailableThemes() Returns array of available theme names. Returns: Table of theme name strings Template Serialization System GUI.saveTemplate(templateName, component, options) Save components or component hierarchies as templates. Parameters: - templateName (string) - Unique template identifier - component - Component to save (can be single or hierarchy) - options (table) - Metadata and configuration Returns: Boolean success -- Save complete UI forms local form = createUserRegistrationForm() GUI.saveTemplate(&quot;UserRegForm&quot;, form, { category = &quot;components&quot;, author = &quot;DevTeam&quot;, description = &quot;User registration form v1.0&quot;, tags = {&quot;forms&quot;, &quot;user-input&quot;, &quot;registration&quot;} }) GUI.loadTemplate(templateName, options) Load and instantiate templates from disk. Parameters: - templateName (string) - Template to load - options (table) - Loading options Returns: Instantiated component or nil -- Load and use template local loadedForm = GUI.loadTemplate(&quot;UserRegForm&quot;, { restoreEventHandlers = false, -- Security option connectToStyles = true -- Apply current theme }) -- Position and use loadedForm.x = 100 loadedForm.y = 200 loadedForm:draw() -- Ready to use GUI.createFromTemplate(templateName, options) Convenience method combining load and positioning. Parameters: - templateName (string) - Template identifier - options (table) - x,y position and other options Returns: Positioned component ready for use GUI.exportTemplate(templateName, format, filename) Export templates for cross-project sharing. Supported Formats: JSON (human-readable), Lua (direct code) Cross-Platform: Import with GUI.importTemplate() Plugin System GUI.loadPlugin(pluginName) Load external component plugins. Parameters: - pluginName (string) - Plugin identifier -- Load plugins for extended functionality GUI.loadPlugin(&quot;advanced_controls&quot;) GUI.loadPlugin(&quot;charts_and_graphs&quot;) print(&quot;Loaded plugins: &quot; .. table.concat(GUI.getLoadedPlugins(), &quot;, &quot;)) GUI.getLoadedPlugins() Returns array of currently loaded plugin names. GUI.getAvailablePlugins() Returns array of discoverable plugin names. Advanced Scene &amp; Layout Management GUI.createScene(name, config) Create complex screen layouts using preset system. Parameters: - name (string) - Scene preset name - config (table) - Scene configuration overrides -- Scene presets available: &quot;menuScene&quot;, &quot;dialogScene&quot;, &quot;settingsScene&quot; local mainMenu = GUI.createScene(&quot;menuScene&quot;, { title = {text = &quot;My Game&quot;}, menuItems = { play = {action = startGame}, options = {action = showOptions}, exit = {action = love.event.quit} } }) Utility Functions GUI.update(dt) Update timing-dependent systems (animations, theme transitions). Parameters: - dt (number) - Delta time from LOVE2D Usage: Call in love.update(dt) GUI.getClass() Returns the OOP base class for component development. Returns: Class constructor local Class = GUI.getClass() local MyComponent = Class:extend() function MyComponent:new(x, y) self.x, self.y = x, y end Global Managers Access GUI.SceneManager : Scene transition management GUI.StyleManager : Theme and style coordination GUI.ToastManager : Notification system GUI.i18n : Internationalization system GUI.SoundSystem : Audio feedback system GUI.ComponentFactory : Component creation factory Advanced Features Reference Complete Component List button - Interactive buttons with states text - Text display with alignment, shadows, outlines slider - Value selectors with tooltips image - Image display with scaling, tinting panel - Containers with scrollbars, clipping toast - Notifications with auto-dismiss tooltip - Floating help text animatedText - Text with typewriter effects textButton - Text-only clickable buttons editableText - Single-line text input filePicker - File selection dialogs Custom components via plugin system Built-in Preset Categories Layout Presets : dialog , menu , notification Component Presets : formField , settingItem , toolbar Scene Presets : menuScene , dialogScene , settingsScene Supported Events (All Components) mousepressed(x, y, button) mousemoved(x, y, dx, dy) mousereleased(x, y, button) keypressed(key, isrepeat) textinput(text) update(dt) This library provides professional-grade UI capabilities with 100+ functions across all major systems, supporting custom extensibility through plugins and templates for maximum developer flexibility. Distribution &amp; Packaging The library supports multiple distribution methods depending on your project's needs: As a LOVE2D Game Component Best for: Single-game projects, game jams, complete game bundles Copy the library into your game's structure: my-game/ ├── main.lua # Your game code ├── gui/ # Copy entire gui/ folder │ ├── init.lua │ ├── components/ │ ├── themes/ │ └── ... ├── assets/ # Your game assets └── conf.lua Use in your main.lua : ```lua local GUI = require(\"gui\") function love.load() GUI.init({theme = \"eighties_terminal\"}) -- Create your UI... end ``` Package as .love file : bash zip -r my-game.love * As a Reusable Library Best for: Multiple projects, team development, library distribution Option 1: LOVE2D Shared Location Install globally in LOVE2D directory: ``` # On Windows C:\\Users\\YOUR_NAME\\AppData\\Roaming\\LOVE\\gui\\ # Copy entire gui/ folder to this location ``` Use in any project : lua -- Will automatically find gui/ in LOVE directory local GUI = require(\"gui\") Option 2: Version Controlled Library Structure your repo : ├── lib/ │ └── gui/ # GUI library ├── shared/ │ └── gui/ # Symlink to lib/gui/ └── projects/ ├── game1/ ├── game2/ └── ... Update shared link when library updates Minimal Distribution Best for: Small projects, embedded systems, resource-constrained environments Use only core components : lua GUI.init({ components = {\"button\", \"text\", \"panel\"}, -- Only load what you need plugins = false -- Disable plugin system }) Create custom minimal build : - Strip unused themes - Remove documentation assets - Compress textures Cross-Platform Distribution For all platforms LOVE2D supports (Windows, macOS, Linux, Android, iOS): Develop on desktop first - easier debugging Test touch events on target devices Theme optimization for different screen DPI Asset optimization for mobile bandwidth/storage Advanced Integration Patterns NPM-style Package Management Create a simple package.json equivalent: -- gui_package.lua return { name = &quot;vibe-gui&quot;, version = &quot;1.0.0&quot;, description = &quot;Modern GUI library for LOVE2D&quot;, main = &quot;gui/init.lua&quot;, dependencies = { flux = &quot;&gt;=1.0.0&quot;, classic = &quot;&gt;=1.0.0&quot; }, author = &quot;GUI Team&quot;, license = &quot;MIT&quot; } CI/CD Pipeline Integration # .github/workflows/release.yml name: Release GUI Library on: push: tags: ['v*'] jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Create Release Archive run: | zip -r vibe-gui-${{ github.ref_name }}.zip gui/ - name: Upload Release uses: actions/upload-release-asset@v1 with: upload_url: ${{ github.event.release.upload_url }} asset_path: vibe-gui-${{ github.ref_name }}.zip Using with Build Tools Makefile Distribution GUI_VERSION=1.0.0 gui-dist: clean mkdir -p dist/vibe-gui-$(GUI_VERSION) cp -r gui/ dist/vibe-gui-$(GUI_VERSION)/ cp README.md LICENSE.txt dist/vibe-gui-$(GUI_VERSION)/ cd dist &amp;&amp; zip -r vibe-gui-$(GUI_VERSION).zip vibe-gui-$(GUI_VERSION)/ CMake Integration (for complex projects) # CMakeLists.txt cmake_minimum_required(VERSION 3.0) project(MyGame) # Add GUI library add_subdirectory(lib/gui) # Link to your game target_link_libraries(my_game vibe_gui) Performance Optimization Bundle Analysis : See what's included lua print(\"Components loaded: \" .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), \", \")) print(\"Themes available: \" .. table.concat(GUI.getAvailableThemes(), \", \")) Selective Loading : lua -- Only load what you need local config = { loadOnly = {\"button\", \"text\", \"slider\"}, -- Custom filter skipLoaders = {\"plugins\", \"extra_themes\"} -- Skip heavy features } Memory Management : - Templates auto-save/load to reduce memory - Canvas recycling for performance - Lazy component loading Testing Your Distribution Use the included examples to validate your distribution: # Test minimal example e:\\LOVE\\love.exe examples/simple_gui.lua # Test advanced features e:\\LOVE\\love.exe examples/animation_gallery.lua # Test template system e:\\LOVE\\love.exe examples/template_demo.lua Contributing Back When contributing to the library: Follow existing structure in gui/ folder Update package.json if adding dependencies Test distribution in multiple environments Update version in both main.lua and package file This ensures the library remains easily distributable and maintainable for the LOVE2D community. Examples The library includes 7 comprehensive examples demonstrating different use cases: Core Examples simple_gui.lua - Entry-level component creation and basic interactions advanced_usage.lua - Custom components, preset creation, and advanced patterns Feature-Specific Examples animation_gallery.lua - Complete interactive demo of 35+ animation presets layout_demo.lua - Advanced layout strategies (Grid, Flex, Flow layouts) plugin_demo.lua - Loading external plugins and extending functionality template_demo.lua - Template saving/loading with interactive management theme_switcher_demo.lua - Runtime theme switching and visual comparisons Quick Start Examples Testing Your Installation # Run the basic demo e:\\LOVE\\love.exe examples/simple_gui.lua # See all animation capabilities e:\\LOVE\\love.exe examples/animation_gallery.lua # Test template system e:\\LOVE\\love.exe examples/template_demo.lua Minimal Integration Example -- Install GUI globally in %APPDATA%\\LOVE\\gui\\ local GUI = require(&quot;gui&quot;) function love.load() GUI.init({theme = &quot;eighties_terminal&quot;}) local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, text = &quot;Hello!&quot;, action = function() toastManager:add({text = &quot;Welcome to Vibe GUI!&quot;}) end }) self.button = btn end -- ... rest of LOVE2D callbacks Example Project Templates Game Menu System -- Based on template_demo.lua pattern local GUI = require(&quot;gui&quot;) function createMainMenu() return GUI.createPreset(&quot;menu&quot;, { title = {text = &quot;My Awesome Game&quot;}, button1 = {text = &quot;Start Game&quot;, action = startGame}, button2 = {text = &quot;Options&quot;, action = showOptions}, button3 = {text = &quot;Exit&quot;, action = love.event.quit} }) end Settings Panel -- Based on advanced_usage.lua pattern local GUI = require(&quot;gui&quot;) function createSettingsPanel() return GUI.createPreset(&quot;dialog&quot;, { title = {text = &quot;Settings&quot;}, content = {text = &quot;Adjust your preferences:&quot;}, -- Volume slider (from settingItem preset) volumeSection = { type = &quot;settingItem&quot;, label = {text = &quot;Master Volume:&quot;}, slider = {rangeMax = 100} }, -- Fullscreen toggle fullscreenBtn = {action = toggleFullscreen} }) end Real-World Usage Patterns See the examples for full implementations of these patterns: Form Handling : Complete user registration forms with validation Dynamic Content : Real-time updates and state management Component Composition : Building complex UI from simple components Resource Management : Loading/unloading assets as needed Cross-Device Adaptation : Responsive layouts for different screen sizes Migration Guide From Manual Requires Old approach: local Button = require(&quot;gui.components.button&quot;) local button = Button(100, 100, &quot;Click&quot;, 200, 50, function() end) New modular approach: local button = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click&quot;, action = function() end }) Backward Compatibility The library maintains backward compatibility - you can still manually require and use components directly if needed, but the new factory approach is recommended for better modularity. Developer Experience &amp; Best Practices Troubleshooting Common Issues Component Not Drawing -- Issue: Your component isn't showing up function love.draw() -- Do you call love.graphics.clear() BEFORE drawing? love.graphics.clear(0.1, 0.1, 0.15) -- Did you call component:draw()? myButton:draw() -- Is your component positioned within screen bounds? print(myButton.x, myButton.y) -- Debug coordinates end Event Handler Not Working -- Issue: Button clicks aren't registering local btn = GUI.createComponent(&quot;button&quot;, { x = 100, y = 100, width = 200, height = 50, text = &quot;Click me&quot;, action = function() print(&quot;Button pressed!&quot;) -- This should work end }) function love.mousepressed(x, y, button) btn:mousepressed(x, y, button) -- Don't forget this! end Animations Not Playing -- Issue: GUI.animate() isn't working function love.load() GUI.init({ theme = &quot;eighties_terminal&quot; -- The AnimationPresets system auto-initializes }) -- This should work AUTOMATICALLY now GUI.animate(myComponent, &quot;button.success&quot;) end function love.update(dt) GUI.update(dt) -- REQUIRED for animations to work! end Template Save/Load Issues -- Common template problems print(&quot;Available templates: &quot; .. table.concat(GUI.listTemplates(), &quot;, &quot;)) -- Template not loading? local success = GUI.saveTemplate(&quot;test&quot;, component, { category = &quot;components&quot; -- Required field }) -- Template path conflicts? GUI.TemplateSerializer:setTemplateDir(&quot;my/templates/&quot;) -- Custom location Plugin Loading Failures -- Debug plugin issues print(&quot;Looking for plugins in: &quot; .. GUI.getPluginPath()) -- Plugin discovery issues? print(&quot;Found plugins: &quot; .. table.concat(GUI.getAvailablePlugins(), &quot;, &quot;)) -- Try explicit path GUI.PluginSystem:addPluginPath(&quot;my/custom/plugins/&quot;) Performance Optimization Selective Component Loading -- Only load what you need GUI.init({ components = {&quot;button&quot;, &quot;text&quot;, &quot;slider&quot;} -- Skip unused components }) -- Check what's loaded print(&quot;Loaded components: &quot; .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), &quot;, &quot;)) Canvas Optimization -- Enable canvas optimization for panels (already enabled by default) local panel = GUI.createComponent(&quot;panel&quot;, { x = 100, y = 100, width = 400, height = 300, -- Canvas rendering is automatic for performance }) -- Manual canvas control if needed panel:setCanvasEnabled(true) -- Faster rendering, higher memory panel:setCanvasEnabled(false) -- Slower but less memory Animation Performance -- Stop animations when not needed GUI.stopAllAnimations() -- Emergency cleanup -- Limit concurrent animations local animationCount = GUI.AnimationPresets:getActiveAnimationCount() if animationCount &gt; 10 then GUI.stopOldestAnimation() end Theme Optimization -- Preload themes to avoid runtime switching costs GUI.StyleManager:loadTheme(&quot;retro&quot;) GUI.StyleManager:loadTheme(&quot;modern&quot;) -- Switch instantly without transitions GUI.switchTheme(&quot;retro&quot;, {transition = &quot;none&quot;}) Memory Management Template Caching -- Templates are cached for performance local template = GUI.loadTemplate(&quot;form&quot;) -- First load -- Subsequent loads return cached copy local instance2 = GUI.loadTemplate(&quot;form&quot;) -- Instant Component Cleanup -- Proper component cleanup function cleanupScreen() -- Stop animations GUI.stopAllAnimations() -- Clear templates if needed GUI.TemplateSerializer:clearCache() -- Remove event handlers for _, component in ipairs(myComponents) do component.action = nil -- Remove callbacks end end Resource Monitoring -- Debug memory usage print(&quot;Templates in memory: &quot; .. GUI.TemplateSerializer:getCacheSize()) print(&quot;Active animations: &quot; .. GUI.AnimationPresets:getActiveAnimationCount()) print(&quot;Loaded plugins: &quot; .. #GUI.getLoadedPlugins()) -- Clean up periodically if math.random() &lt; 0.1 then -- 10% chance each frame GUI.TemplateSerializer:cleanupLRU() -- Remove least recently used end Best Practices Component Organization function createUIScreen() -- Group related components local ui = { header = createHeader(), content = createContentArea(), footer = createFooter() } -- Store references for cleanup self.currentUI = ui return ui end function cleanupScreen() if self.currentUI then GUI.stopAnimationsInGroup(self.currentUI) self.currentUI = nil end end Event Handler Management local handlers = {} function setupEventHandlers() -- Store handler references handlers.button1 = function() print(&quot;Button 1&quot;) end handlers.button2 = function() print(&quot;Button 2&quot;) end local btn1 = GUI.createComponent(&quot;button&quot;, { text = &quot;Button 1&quot;, action = handlers.button1 }) local btn2 = GUI.createComponent(&quot;button&quot;, { text = &quot;Button 2&quot;, action = handlers.button2 }) return {btn1, btn2} end function cleanupEventHandlers() -- Clear all handlers to prevent memory leaks for k, v in pairs(handlers) do handlers[k] = nil end end Error Handling -- Safe component creation function createWithFallback(type, params, fallbackType) local component, success = pcall(GUI.createComponent, type, params) if not success then print(&quot;Failed to create &quot; .. type .. &quot;, using fallback&quot;) component = GUI.createComponent(fallbackType, params) end return component end -- Template loading with error handling local template, success = pcall(GUI.loadTemplate, &quot;user_form&quot;) if not success then print(&quot;Template not found, creating default&quot;) template = createDefaultForm() end Theme Compatibility -- Ensure theme compatibility function applyThemeSafely(themeName) if GUI.StyleManager:themeExists(themeName) then GUI.switchTheme(themeName) else print(&quot;Theme &quot; .. themeName .. &quot; not found, using default&quot;) GUI.switchTheme(&quot;eighties_terminal&quot;) end end Development Workflow Hot Reloading Support -- For development - reload components without restart function developmentReload() if love.keyboard.isDown(&quot;r&quot;) and love.keyboard.isDown(&quot;ctrl&quot;) then print(&quot;Reloading GUI...&quot;) package.loaded[&quot;gui&quot;] = nil GUI = require(&quot;gui&quot;) GUI.init() -- Reinitialize end end Debug Overlay function debugOverlay() local debugInfo = { &quot;FPS: &quot; .. tostring(love.timer.getFPS()), &quot;Components: &quot; .. table.concat(GUI.ComponentFactory:getRegisteredTypes(), &quot;, &quot;), &quot;Themes: &quot; .. table.concat(GUI.getAvailableThemes(), &quot;, &quot;), &quot;Templates: &quot; .. #GUI.listTemplates(), &quot;Memory: &quot; .. collectgarbage(&quot;count&quot;) .. &quot;KB&quot; } love.graphics.setColor(0, 0, 0, 0.5) love.graphics.rectangle(&quot;fill&quot;, 10, 10, 300, #debugInfo * 20 + 10) love.graphics.setColor(1, 1, 1) for i, info in ipairs(debugInfo) do love.graphics.print(info, 20, 20 + i * 20) end end Cross-Platform Considerations Mobile Considerations -- Detect mobile platforms local isMobile = love.system.getOS() == &quot;Android&quot; or love.system.getOS() == &quot;iOS&quot; if isMobile then -- Larger touch targets buttonSize = 60 -- Enable touch-friendly gestures end -- Platform-specific optimizations if love.system.getOS() == &quot;Android&quot; then -- Android-specific settings love.window.setMode(0, 0, {resizable = false}) end Desktop Considerations -- Desktop mouse/keyboard optimizations function love.wheelmoved(x, y) local mouseX, mouseY = love.mouse.getPosition() -- Panel scrolling if myPanel:isMouseOver(mouseX, mouseY) then myPanel:scroll(0, y * 20) -- Scroll panels end end This developer guide covers 90% of common issues and provides battle-tested patterns for production use. Requirements LOVE2D 11.0+ Required dependencies: flux, classic OOP library Optional: Additional asset files for themes Contributing To add new components: 1. Create the component in gui/components/ 2. Register it in ComponentFactory:init() 3. Add parameter mapping if needed 4. Update this README License This project is open source. See LICENSE file for details."
  },
  {
    "title": "Voxel64",
    "url": "voxel64/index.html",
    "date": "2025-01-01",
    "content": "A simple voxel space renderer for Love2D, simulating 3D terrain flight using heightmaps. repository Based on s-macke/VoxelSpace Features Procedural terrain rendering based on height and color maps Flight controls for navigation Multiple terrain maps included Basic HUD display Requirements Love2D game engine Running Run the game with: love /path/to/voxel64-master Controls W/A/S/D: Move forward/left/back/right Arrow up/down: Increase/decrease height Numbers 1-5: Switch maps H: Toggle HUD Esc: Quit voxel64 Un semplice render voxel space per Love2D, che simula il volo 3D su terreni utilizzando heightmaps. Caratteristiche Rendering procedurale di terreni basato su mappe di altezza e colore Controlli di volo per la navigazione Più mappe di terreno incluse Display HUD di base Requisiti Game engine Love2D Esecuzione Esegui il gioco con: love /path/to/voxel64-master Controlli W/A/S/D: Muovi avanti/sinistra/indietro/destra Frecce su/giù: Aumenta/diminuisci altezza Numeri 1-5: Cambia mappa H: Mostra/nascondi HUD Esc: Esci × ‹ ›"
  }
]